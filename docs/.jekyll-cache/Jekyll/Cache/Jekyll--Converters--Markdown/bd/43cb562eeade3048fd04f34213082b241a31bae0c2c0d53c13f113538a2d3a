I"LX<h2 id="the-easier-architecture">The EASIER Architecture</h2>

<p>The EASIER architecture is illustrated in the following figure.</p>

<p><img src="assets/images/process.png" alt="EASIER architecture" /></p>

<p>The figure is vertically divided in two swimlanes. The evolutionary context is on the left, while on the right there is the Architecture Description Language (aka ADL)  context.</p>

<h3 id="evolutionary-context">Evolutionary context</h3>

<p>The bottom left side of figure illustrates the EASIER core, that is a multi-objective evolutionary algorithm based on the NSGA-II <a href="https://doi.org/10.1109/4235.996017">Deb 2002</a>.</p>

<p>In particular, we adopted <a href="https://github.com/jMetal/jMetal">JMetal</a> as a reference library, which is a well established object–oriented Java-based framework for multi-objective optimization with metaheuristics.</p>

<h4 id="data-layer">Data layer</h4>

<p>An EASIER Solution represents a a sequence of a number $len$ of architectural RefactoringActions. Both Refactorings and RefactoringActions have PreConditions and PostConditions, which are first-order logical formulae evaluated during the evolutionary process to determine their feasibility.</p>

<p>The adopted mechanism for calculating and verifying Refactorings and RefactoringActions pre(post)conditions is an implementation of the one in <a href="https://doi.org/10.1145/602461.602499">Cinneide 2000</a>.</p>

<p>A Solution also contains a reference to the corresponding alternative architecture. 
Each Solution has three attributes that together represent the objectives of our fitness function, namely $ArchDist$, $PerfQ$ and $#PAs$.</p>

<h4 id="process">Process</h4>

<p>Conformingly to the typical NSGA-II flow, the first iteration of the algorithm consists of a generation phase, aimed at randomly creating an initial population of candidate solutions (i.e. refactorings by $len$ length) with a $pop$ cardinality.</p>

<p>After the generation of the initial population, solutions are evaluated with respect to the fitness function three objectives. In particular,</p>
<ul>
  <li>PerfQ (to maximize). It represents a performance quality indicator aimed at quantifying the relative performance improvement induced by a refactoring with respect to an initial architecture, and defined as follows. 
Let <code class="highlighter-rouge">I</code> be the result of a performance analysis on the initial architecture w.r.t. to a vector of $c$ performance measures of interest (e.g. throughputs, utilizations, \dots), and let <code class="highlighter-rouge">I&lt;sub&gt;k&lt;\sub&gt;</code> denote the <code class="highlighter-rouge">k--th</code> element of this vector (e.g. a throughput value associated to a given component of the system). Let $F$ be the result of a performance analysis, w.r.t. the same measures of interest, on a generic architectural alternative $A$, as obtained by applying a refactoring to the initial architecture. Analogously, let $F_k$ denote the $k$–th element of $F$. 
Then the value of performance quality indicator associated to $A$ is defined as: [\small PerfQ(A)=\frac{1}{c}\left(\sum\limits_{j=1}^{c} p\cdot \big(\frac{F_j-I_j}{F_j+I_j}\big)\right),]
where <code class="highlighter-rouge">p\in\{-1,1\}</code> is a multiplying factor that holds: 
  i. $1$ if the $j$–th measure has to be maximized (i.e., the higher the value, the better the overall performance), like the throughput;  $-1$ if the $j$–th measure has to be minimized, like response time. In this way, a decrease in the value of a measure that one would like to minimize is interpreted as a positive contribution. 
Notice that for performance measures representing utilizations $p$ also holds $1$ but, similarly to \cite{DBLP:conf/wosp/MenasceEGMS10}, we have defined a \emph{correction factor} $\Delta_j$, to be added to each $j$–th term above, whose purpose is to penalize refactorings that push the utilization too close to its maximum value of $1$. In particular, our algorithm tends to maximize utilization up to a certain threshold, whereas utilizations higher than this threshold are rather considered as risky. 
For sake of our implementation, we have adopted a threshold value of $0.8$, but this can be easily changed within EASIER. In particular:</li>
</ul>

<p><img src="assets/images/perfq-math.png" alt="PerfQ Math equation" /></p>

<ul>
  <li>
    <p>ArchDist (to minimize). It quantifies the distance of an architectural alternative $A$ from the initial one, in terms of intensity of refactoring changes. The distance of $A$ from an initial one is defined as the sum of the distance induced by each RefactoringAction $a_i$ in the corresponding genome. 
Note that, in the current version of EASIER, $ArchDist(a_i)$ is assumed to be predefined for each \texttt{RefactoringAction}. The setting of these values is left to software architects, because they might depend on the characteristics of the specific ADL and/or the application domain. $\qquad\qquad\qquad\square$</p>
  </li>
  <li>
    <p>#PAs (to minimize). It counts the number of performance antipatterns (PAs) occurrences within an alternative architecture. In its current version, EASIER supports OCL~\cite{warmer2003object} for antipatterns detection rules specification and verification, which represents yet another entry point. In fact, these rules depend on the ADL expressiveness, thus they must be provided when plugging a new ADL context into EASIER.</p>
  </li>
</ul>

<p>At the best of our knowledge, EASIER is the first approach that considers the number of PAs as an objective of an evolutionary algorithm’s fitness function.
Our intent is to start investigating whether PAs in EASIER can play an analogous role of, respectively, architectural tactics in \cite{Koziolek:2011cg} and architectural patterns in \cite{DBLP:conf/wosp/MenasceEGMS10}, that are guiding the search process with additional architectural knowledge. In our case they are negative practices to be avoided, whereas in the other two cases were positive practices to be adopted. $\qquad\qquad\square$</p>

<p>After the (custom) evaluation, non-dominated solutions (i.e. solutions that are better than all others w.r.t. at least one objective) are \textbf{ranked} according to the notion of crowding distance~\cite{Deb:2002ut}, and the best ones among them are then \textbf{selected} and used as \textit{reproductive basis} for the next iterations. 
In particular, in each subsequent iteration, new sets of candidate solutions are generated by randomly applying (custom) \textit{crossover} and \textit{mutation} operators to the reproductive basis of the previous step, with probabilities $p(xover)$ and $p(mut)$.</p>

<p>Concerning crossover, in EASIER a \textbf{(custom) operator} is applied onto two parent \texttt{Refactoring}s $r_1$ and $r_2$ selected by tournament~\cite{Eiben201119}. The crossover point $x$ is chosen (uniformly at random) to be an integer value within the range $[1,len-1]$. Then, two children are generated by single-point crossover-based strategy as follows: the first $x$ actions of $r_1$ are combined with the second $len-x$ actions of $r_2$ and viceversa, as long as the $x$–th action of $r_1$ is \textit{compatible}  with the $(x+1)$–th action of $r_2$. On the contrary, the child is discarded and one of the parents replaces it.</p>

<p>Concerning mutation, in EASIER we defined a \textbf{(custom) operator} that randomly choses a \texttt{RefactoringAction} of the considered  \texttt{Refactoring} and replaces it with another \textit{compatible}, randomly generated, \texttt{RefactoringAction}.</p>

<p>After the application of crossover and mutation operators, the obtained candidate solutions are in turn \textbf{evaluated} and \textbf{selected} for the next iteration, as for the initial population. 
The process proceeds for a number $epo$ of iterations that is given by $evals/pop$. After $epo$ iterations, the available solutions are once more compared each other and the set of non-dominated ones, namely the \textit{Pareto frontier}, is returned.</p>

<p>Finally, we remark that each generated architectural alternative undergoes a \textit{Performance Analysis} process in order to obtain performance indices of interest for the corresponding architectural model. 
Such process strictly depends on the target ADL, which may need some processing before and after plugging a specific performance analyzer within EASIER. 
In other words, a ``bridge’’ between \customAlgo and the Performance Analyzer has to be provided that, in one direction, calls a solver for the architectural model and, in the other direction, properly fills back performance measures into the model. 
%</p>

<p>###{\aemilia ADL context}
\label{sec:pakimor:aemilia}</p>

<p>On the right side of Fig.~\ref{fig:evoAlg} we show how an ADL context can be plugged into EASIER. In this description we make specific reference to \aemilia, that is the ADL we have chosen for sake of this paper~\cite{Bernardo:2002gl}.</p>

<p>\vspace{.2cm}
\subsubsection{Data}
\label{sec:pakimor:aemilia:datastruct}</p>

<p>In order to plug a new ADL in EASIER, ADL-specific refactoring actions have to be provided, which in Fig. \ref{fig:evoAlg} have been reported as specializations of \texttt{AEmiliaRefactoringAction}, i.e. \texttt{CloneAEI} and \texttt{ChangeRate}. Hence, the ADL plug, at the level of actions, consists here in the specialization of the \texttt{RefactoringAction} concept, defined in the evolutionary context as an EASIER entry point, as an \texttt{AEmiliaRefactoringAction}.</p>

<p>\texttt{CloneAEI} is in charge of cloning a \textit{srcAEI} \aemilia component, given as input, which is randomly selected from the \aemilia architectural specification. From an architectural point of view, the straightforward semantics for \texttt{CloneAEI} is the deployment of a copy of the original component. We have implemented this action by explicitly modifying the ports of the original component and of its neighbors, hence this action is more complex than similar actions introduced up today in literature (e.g. changing a component multiplicity). We have conceived it as an action that can be expanded in the context of software refactoring, for example by introducing some pre-defined (static and behavioral) differences in the new component with respect to the original one.</p>

<p>\texttt{ChangeRate} modifies a randomly selected rate of an \aemilia action by multiplying its value by an uniformly distributed \textit{FactorOfChange} (FOC). \texttt{ChangeRate} intends to represent the option of both enhancing and worsening the performance of a certain action, so that \customAlgo is enabled to find an optimal balance between slower and faster actions. Note that the \texttt{ChangeRate} semantics, in the \aemilia context, is twofold, because it can be charged either to the software contribution of an action (i.e., modifying the complexity of the action) or to the hardware one (e.g., replacing the engine that executes the action with another one). 
\textit{FactorOfChange} has been defined as $FOC \in [0.5, 2], FOC \neq 1$, so that the ranges of new actions can go up to double or down to halve the original ones. However, this range can be modified without impact on EASIER.</p>

<p>We have associated $ArchDist$ values to $1.3$ and $1$ for \texttt{CloneAEI} and \texttt{ChangeRate}, respectively. This is only one possible setting of the distance to which refactoring leads an alternative architecture from the initial one. Other choices can be made, depending on the ADL and the application context.</p>

<p>Finally, in order to generate architectural alternatives that conform to the \aemilia ADL grammar, we have added three constraints onto a refactoring sequence, that are: (i) an AEI cannot be cloned more than once in a sequence, otherwise complex incompatibilities between ports occur; (ii) once cloned an AEI in a sequence, none of its neighbour AEIs can be cloned, due to the same reason as before; (iii) each rate can be changed only once in a sequence, because we want $FOC$ to limit the range of a rate change in each sequence.</p>

<p>ADL-specific refactoring actions are collected into an ADL-dependent Refactoring Actions Library, as shown in Fig.  \ref{fig:evoAlg}. 
%</p>

<p>An \aemilia architectural specification is basically a textual file (.aem), which conforms to a particular grammar embedding, among topological concepts (i.e., architectural types, instances and connectors), behavioral semantics of architectural elements expressed following an internally defined stochastic process algebra~\cite{Bernardo:2002gl}.
In order to enable performance analysis of an \aemilia architectural specification, performance measures of interest must be specified (i.e. throughputs and/or utilizations of  AEIs/interactions). EASIER currently supports one analysis method, among the ones provided by the \aemilia solver \textit{TwoTowers}~\cite{TwoTowers}, that is \textit{Stationary/Transient Reward-Based Measure Calculator}. 
For sake of such type of analysis, performance measures have to be specified into an additional textual file (.rew). Once performance analysis has been completed, indices are available into a textual file (.val).</p>

<p>A further ADL-dependent element to provide for plugging a new ADL in EASIER is represented by PAs detection rules, which had been defined as first-order logics formulae \cite{Cortellessa:2014cs}. The current EASIER \aemilia context supports the \textit{Pipe\&amp;Filter} performance antipattern (PaF), which  occurs when the slowest filter, in a ``pipe and filter’’ architecture, causes a system interaction to have unacceptable throughput~\cite{Smith:2003wv}. The original logical formula of PaF in \cite{Cortellessa:2014cs} has been implemented as an OCL rule within the \aemilia context as follows:% (\footnote{Note that the OCL implementation of the PaF detection rule is much more complex than its first-order logics definition, due to the depth of the \aemilia metamodel, which in some sense maps 1:1 to the \aemilia grammar.}):
$\exists i \in \mathrm{I}, \mid rate(i) \geq Th_{rateLB} \wedge p(i) = 1 \wedge throughput(i) &lt; Th_{throughputUB}$,
where: 
$i$ is an element of the set $\mathrm{I}$ of all Architectural Interactions;
$p(i)$ is its probability of execution;
$Th_{rateLB}$ and $Th_{throughputUB}$ are threshold values that represent, respectively, a lower bound for $rate(i)$ and an upper bound for $throughput(i)$, over which the antipattern occurs.
The .ocl file implementing the PaF detection rule is evaluated against each generated architectural alternative, and the number of detected PAs is given as input to \customAlgo during the evaluation phases.</p>

<p>\vspace{.2cm}
\subsubsection{Process}
\label{sec:pakimor:aemilia:process}</p>

<p>We recall that EASIER evolutionary context works on solutions containing a reference to the corresponding architectural alternative resulting from the application of the genome refactoring sequence and conforming to an ADL metamodel. 
Hence, in case of \aemilia, textual specifications need to undergo a technical in-place text-to-model transformation from the \aemilia grammar to the \aemilia metamodel. 
A model-based infrastructure was proposed in~\cite{DBLP:conf/wicsa/CortellessaSMT12} to this goal, providing the \aemilia metamodel and the text-to-model transformation from textual specifications to models (.mmaemilia) conforming to such metamodel. These model-based features are provided within a single environment, in the context of a pre-existing open-source tool named \textit{TwoEagles}~
\cite{DBLP:conf/epew/BernardoCF11}.</p>

<p>%
As required in the evolutionary context, we have implemented a bridge, namely \textit{TwoEaglesBridge}, between \customAlgo and \textit{TwoEagles}. \textit{TwoEaglesBridge} allows to obtain an \aemilia model annotated with performance indices. In particular, for each candidate solution generated during \customAlgo execution, the bridge executes the following automated steps:
(i) It applies the refactoring to the initial architecture, thus resulting in a Refactored Architectural Alternative (.mmaemilia);
(ii) It applies the model-to-text transformation of the obtained \aemilia model (.mmaemilia), which produces a corresponding textual file (.aem) processed by TwoTowers;
(iii) It executes the performance analysis, that takes as input .aem and .rew files, and computes performance indices (.val file);
(iv) It fills the obtained performance indices (namely \textit{Measures To Indices}) into the model reported by the evolutionary context to enable the computation of $PerfQ$ and $#PAs$.
(v) It updates the refactoring genome.</p>

<p>Text can be <strong>bold</strong>, <em>italic</em>, <del>strikethrough</del> or <code class="highlighter-rouge">keyword</code>.</p>

<p><a href="./another-page.html">Link to another page</a>.</p>

<p>There should be whitespace between paragraphs.</p>

<p>There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project.</p>

<h1 id="header-1">Header 1</h1>

<p>This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere.</p>

<h2 id="header-2">Header 2</h2>

<blockquote>
  <p>This is a blockquote following a header.</p>

  <p>When something is important enough, you do it even if the odds are not in your favor.</p>
</blockquote>

<h3 id="header-3">Header 3</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Javascript code with syntax highlighting.</span>
<span class="kd">var</span> <span class="nx">fun</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">lang</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">dateformat</span><span class="p">.</span><span class="nx">i18n</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./lang/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">l</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Ruby code with syntax highlighting</span>
<span class="no">GitHubPages</span><span class="o">::</span><span class="no">Dependencies</span><span class="p">.</span><span class="nf">gems</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">gem</span><span class="p">,</span> <span class="n">version</span><span class="o">|</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">add_dependency</span><span class="p">(</span><span class="n">gem</span><span class="p">,</span> <span class="s2">"= </span><span class="si">#{</span><span class="n">version</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="header-4">Header 4</h4>

<ul>
  <li>This is an unordered list following a header.</li>
  <li>This is an unordered list following a header.</li>
  <li>This is an unordered list following a header.</li>
</ul>

<h5 id="header-5">Header 5</h5>

<ol>
  <li>This is an ordered list following a header.</li>
  <li>This is an ordered list following a header.</li>
  <li>This is an ordered list following a header.</li>
</ol>

<h6 id="header-6">Header 6</h6>

<table>
  <thead>
    <tr>
      <th style="text-align: left">head1</th>
      <th style="text-align: left">head two</th>
      <th style="text-align: left">three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good swedish fish</td>
      <td style="text-align: left">nice</td>
    </tr>
    <tr>
      <td style="text-align: left">out of stock</td>
      <td style="text-align: left">good and plenty</td>
      <td style="text-align: left">nice</td>
    </tr>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good <code class="highlighter-rouge">oreos</code></td>
      <td style="text-align: left">hmm</td>
    </tr>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good <code class="highlighter-rouge">zoute</code> drop</td>
      <td style="text-align: left">yumm</td>
    </tr>
  </tbody>
</table>

<h3 id="theres-a-horizontal-rule-below-this">There’s a horizontal rule below this.</h3>

<hr />

<h3 id="here-is-an-unordered-list">Here is an unordered list:</h3>

<ul>
  <li>Item foo</li>
  <li>Item bar</li>
  <li>Item baz</li>
  <li>Item zip</li>
</ul>

<h3 id="and-an-ordered-list">And an ordered list:</h3>

<ol>
  <li>Item one</li>
  <li>Item two</li>
  <li>Item three</li>
  <li>Item four</li>
</ol>

<h3 id="and-a-nested-list">And a nested list:</h3>

<ul>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item
        <ul>
          <li>level 3 item</li>
          <li>level 3 item</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item</li>
      <li>level 2 item</li>
    </ul>
  </li>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item</li>
    </ul>
  </li>
  <li>level 1 item</li>
</ul>

<h3 id="small-image">Small image</h3>

<p><img src="https://github.githubassets.com/images/icons/emoji/octocat.png" alt="Octocat" /></p>

<h3 id="large-image">Large image</h3>

<p><img src="https://guides.github.com/activities/hello-world/branching.png" alt="Branching" /></p>

<h3 id="definition-lists-can-be-used-with-html-syntax">Definition lists can be used with HTML syntax.</h3>

<dl>
<dt>Name</dt>
<dd>Godzilla</dd>
<dt>Born</dt>
<dd>1952</dd>
<dt>Birthplace</dt>
<dd>Japan</dd>
<dt>Color</dt>
<dd>Green</dd>
</dl>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The final element.
</code></pre></div></div>
:ET