I"JE<h2 id="the-easier-architecture">The EASIER Architecture</h2>

<p>The EASIER architecture is illustrated in the following figure.</p>

<p><img src="assets/images/process.png" alt="EASIER architecture" /></p>

<p>The figure is vertically divided in two swimlanes. The evolutionary context is on the left, while on the right there is the Architecture Description Language (aka ADL)  context.</p>

<h3 id="evolutionary-context">Evolutionary context</h3>

<p>The bottom left side of figure illustrates the EASIER core, that is a multi-objective evolutionary algorithm based on the NSGA-II <a href="https://doi.org/10.1109/4235.996017">Deb 2002</a>.</p>

<p>In particular, we adopted <a href="https://github.com/jMetal/jMetal">JMetal</a> as a reference library, which is a well established object–oriented Java-based framework for multi-objective optimization with metaheuristics.</p>

<h4 id="data-layer">Data layer</h4>

<p>An EASIER Solution represents a a sequence of a number $len$ of architectural RefactoringActions. Both Refactorings and RefactoringActions have PreConditions and PostConditions, which are first-order logical formulae evaluated during the evolutionary process to determine their feasibility.</p>

<p>The adopted mechanism for calculating and verifying Refactorings and RefactoringActions pre(post)conditions is an implementation of the one in <a href="https://doi.org/10.1145/602461.602499">Cinneide 2000</a>.</p>

<p>A Solution also contains a reference to the corresponding alternative architecture. 
Each Solution has three attributes that together represent the objectives of our fitness function, namely $ArchDist$, $PerfQ$ and $#PAs$.</p>

<h4 id="process">Process</h4>

<p>Conformingly to the typical NSGA-II flow, the first iteration of the algorithm consists of a generation phase, aimed at randomly creating an initial population of candidate solutions (i.e. refactorings by $len$ length) with a $pop$ cardinality.</p>

<p>After the generation of the initial population, solutions are evaluated with respect to the fitness function three objectives. In particular,</p>
<ul>
  <li>
    <p>PerfQ (to maximize). It represents a performance quality indicator aimed at quantifying the relative performance improvement induced by a refactoring with respect to an initial architecture.</p>
  </li>
  <li>
    <p>ArchDist (to minimize). It quantifies the distance of an architectural alternative A from the initial one, in terms of intensity of refactoring changes. The distance of A is defined as the sum of the distance induced by each RefactoringAction a<sub>i</sub> in the corresponding genome.</p>
  </li>
  <li>
    <p>#PAs (to minimize). It counts the number of performance antipatterns (PAs) occurrences within an alternative architecture. In its current version, EASIER exploits the  OCL engine for antipatterns detection rules specification and verification.</p>
  </li>
</ul>

<p>EASIER is the first approach that considers the number of PAs as an objective of an evolutionary algorithm’s fitness function.</p>

<p>After the evaluation, non-dominated solutions are ranked according to the notion of crowding distance, and the best ones are selected and used as reproductive basis for the next iterations.</p>

<p>Finally, each generated architectural alternative undergoes a Performance Analysis process in order to obtain performance indices of interest for the corresponding architectural model. 
Such process strictly depends on the target ADL, which may need some processing before and after plugging a specific performance analyzer within EASIER. 
In other words, a ``bridge’’ between \customAlgo and the Performance Analyzer has to be provided that, in one direction, calls a solver for the architectural model and, in the other direction, properly fills back performance measures into the model. 
%</p>

<h3 id="aemilia-adl-context">AEmilia ADL context</h3>

<p>On the right side of Fig.~\ref{fig:evoAlg} we show how an ADL context can be plugged into EASIER. In this description we make specific reference to \aemilia, that is the ADL we have chosen for sake of this paper~\cite{Bernardo:2002gl}.</p>

<p>\vspace{.2cm}
\subsubsection{Data}
\label{sec:pakimor:aemilia:datastruct}</p>

<p>In order to plug a new ADL in EASIER, ADL-specific refactoring actions have to be provided, which in Fig. \ref{fig:evoAlg} have been reported as specializations of \texttt{AEmiliaRefactoringAction}, i.e. \texttt{CloneAEI} and \texttt{ChangeRate}. Hence, the ADL plug, at the level of actions, consists here in the specialization of the \texttt{RefactoringAction} concept, defined in the evolutionary context as an EASIER entry point, as an \texttt{AEmiliaRefactoringAction}.</p>

<p>\texttt{CloneAEI} is in charge of cloning a \textit{srcAEI} \aemilia component, given as input, which is randomly selected from the \aemilia architectural specification. From an architectural point of view, the straightforward semantics for \texttt{CloneAEI} is the deployment of a copy of the original component. We have implemented this action by explicitly modifying the ports of the original component and of its neighbors, hence this action is more complex than similar actions introduced up today in literature (e.g. changing a component multiplicity). We have conceived it as an action that can be expanded in the context of software refactoring, for example by introducing some pre-defined (static and behavioral) differences in the new component with respect to the original one.</p>

<p>\texttt{ChangeRate} modifies a randomly selected rate of an \aemilia action by multiplying its value by an uniformly distributed \textit{FactorOfChange} (FOC). \texttt{ChangeRate} intends to represent the option of both enhancing and worsening the performance of a certain action, so that \customAlgo is enabled to find an optimal balance between slower and faster actions. Note that the \texttt{ChangeRate} semantics, in the \aemilia context, is twofold, because it can be charged either to the software contribution of an action (i.e., modifying the complexity of the action) or to the hardware one (e.g., replacing the engine that executes the action with another one). 
\textit{FactorOfChange} has been defined as $FOC \in [0.5, 2], FOC \neq 1$, so that the ranges of new actions can go up to double or down to halve the original ones. However, this range can be modified without impact on EASIER.</p>

<p>We have associated $ArchDist$ values to $1.3$ and $1$ for \texttt{CloneAEI} and \texttt{ChangeRate}, respectively. This is only one possible setting of the distance to which refactoring leads an alternative architecture from the initial one. Other choices can be made, depending on the ADL and the application context.</p>

<p>Finally, in order to generate architectural alternatives that conform to the \aemilia ADL grammar, we have added three constraints onto a refactoring sequence, that are: (i) an AEI cannot be cloned more than once in a sequence, otherwise complex incompatibilities between ports occur; (ii) once cloned an AEI in a sequence, none of its neighbour AEIs can be cloned, due to the same reason as before; (iii) each rate can be changed only once in a sequence, because we want $FOC$ to limit the range of a rate change in each sequence.</p>

<p>ADL-specific refactoring actions are collected into an ADL-dependent Refactoring Actions Library, as shown in Fig.  \ref{fig:evoAlg}. 
%</p>

<p>An \aemilia architectural specification is basically a textual file (.aem), which conforms to a particular grammar embedding, among topological concepts (i.e., architectural types, instances and connectors), behavioral semantics of architectural elements expressed following an internally defined stochastic process algebra~\cite{Bernardo:2002gl}.
In order to enable performance analysis of an \aemilia architectural specification, performance measures of interest must be specified (i.e. throughputs and/or utilizations of  AEIs/interactions). EASIER currently supports one analysis method, among the ones provided by the \aemilia solver \textit{TwoTowers}~\cite{TwoTowers}, that is \textit{Stationary/Transient Reward-Based Measure Calculator}. 
For sake of such type of analysis, performance measures have to be specified into an additional textual file (.rew). Once performance analysis has been completed, indices are available into a textual file (.val).</p>

<p>A further ADL-dependent element to provide for plugging a new ADL in EASIER is represented by PAs detection rules, which had been defined as first-order logics formulae \cite{Cortellessa:2014cs}. The current EASIER \aemilia context supports the \textit{Pipe\&amp;Filter} performance antipattern (PaF), which  occurs when the slowest filter, in a ``pipe and filter’’ architecture, causes a system interaction to have unacceptable throughput~\cite{Smith:2003wv}. The original logical formula of PaF in \cite{Cortellessa:2014cs} has been implemented as an OCL rule within the \aemilia context as follows:% (\footnote{Note that the OCL implementation of the PaF detection rule is much more complex than its first-order logics definition, due to the depth of the \aemilia metamodel, which in some sense maps 1:1 to the \aemilia grammar.}):
$\exists i \in \mathrm{I}, \mid rate(i) \geq Th_{rateLB} \wedge p(i) = 1 \wedge throughput(i) &lt; Th_{throughputUB}$,
where: 
$i$ is an element of the set $\mathrm{I}$ of all Architectural Interactions;
$p(i)$ is its probability of execution;
$Th_{rateLB}$ and $Th_{throughputUB}$ are threshold values that represent, respectively, a lower bound for $rate(i)$ and an upper bound for $throughput(i)$, over which the antipattern occurs.
The .ocl file implementing the PaF detection rule is evaluated against each generated architectural alternative, and the number of detected PAs is given as input to \customAlgo during the evaluation phases.</p>

<p>\vspace{.2cm}
\subsubsection{Process}
\label{sec:pakimor:aemilia:process}</p>

<p>We recall that EASIER evolutionary context works on solutions containing a reference to the corresponding architectural alternative resulting from the application of the genome refactoring sequence and conforming to an ADL metamodel. 
Hence, in case of \aemilia, textual specifications need to undergo a technical in-place text-to-model transformation from the \aemilia grammar to the \aemilia metamodel. 
A model-based infrastructure was proposed in~\cite{DBLP:conf/wicsa/CortellessaSMT12} to this goal, providing the \aemilia metamodel and the text-to-model transformation from textual specifications to models (.mmaemilia) conforming to such metamodel. These model-based features are provided within a single environment, in the context of a pre-existing open-source tool named \textit{TwoEagles}~
\cite{DBLP:conf/epew/BernardoCF11}.</p>

<p>%
As required in the evolutionary context, we have implemented a bridge, namely \textit{TwoEaglesBridge}, between \customAlgo and \textit{TwoEagles}. \textit{TwoEaglesBridge} allows to obtain an \aemilia model annotated with performance indices. In particular, for each candidate solution generated during \customAlgo execution, the bridge executes the following automated steps:
(i) It applies the refactoring to the initial architecture, thus resulting in a Refactored Architectural Alternative (.mmaemilia);
(ii) It applies the model-to-text transformation of the obtained \aemilia model (.mmaemilia), which produces a corresponding textual file (.aem) processed by TwoTowers;
(iii) It executes the performance analysis, that takes as input .aem and .rew files, and computes performance indices (.val file);
(iv) It fills the obtained performance indices (namely \textit{Measures To Indices}) into the model reported by the evolutionary context to enable the computation of $PerfQ$ and $#PAs$.
(v) It updates the refactoring genome.</p>

<p>Text can be <strong>bold</strong>, <em>italic</em>, <del>strikethrough</del> or <code class="highlighter-rouge">keyword</code>.</p>

<p><a href="./another-page.html">Link to another page</a>.</p>

<p>There should be whitespace between paragraphs.</p>

<p>There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project.</p>

<h1 id="header-1">Header 1</h1>

<p>This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere.</p>

<h2 id="header-2">Header 2</h2>

<blockquote>
  <p>This is a blockquote following a header.</p>

  <p>When something is important enough, you do it even if the odds are not in your favor.</p>
</blockquote>

<h3 id="header-3">Header 3</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Javascript code with syntax highlighting.</span>
<span class="kd">var</span> <span class="nx">fun</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">lang</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">dateformat</span><span class="p">.</span><span class="nx">i18n</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./lang/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">l</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Ruby code with syntax highlighting</span>
<span class="no">GitHubPages</span><span class="o">::</span><span class="no">Dependencies</span><span class="p">.</span><span class="nf">gems</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">gem</span><span class="p">,</span> <span class="n">version</span><span class="o">|</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">add_dependency</span><span class="p">(</span><span class="n">gem</span><span class="p">,</span> <span class="s2">"= </span><span class="si">#{</span><span class="n">version</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="header-4">Header 4</h4>

<ul>
  <li>This is an unordered list following a header.</li>
  <li>This is an unordered list following a header.</li>
  <li>This is an unordered list following a header.</li>
</ul>

<h5 id="header-5">Header 5</h5>

<ol>
  <li>This is an ordered list following a header.</li>
  <li>This is an ordered list following a header.</li>
  <li>This is an ordered list following a header.</li>
</ol>

<h6 id="header-6">Header 6</h6>

<table>
  <thead>
    <tr>
      <th style="text-align: left">head1</th>
      <th style="text-align: left">head two</th>
      <th style="text-align: left">three</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good swedish fish</td>
      <td style="text-align: left">nice</td>
    </tr>
    <tr>
      <td style="text-align: left">out of stock</td>
      <td style="text-align: left">good and plenty</td>
      <td style="text-align: left">nice</td>
    </tr>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good <code class="highlighter-rouge">oreos</code></td>
      <td style="text-align: left">hmm</td>
    </tr>
    <tr>
      <td style="text-align: left">ok</td>
      <td style="text-align: left">good <code class="highlighter-rouge">zoute</code> drop</td>
      <td style="text-align: left">yumm</td>
    </tr>
  </tbody>
</table>

<h3 id="theres-a-horizontal-rule-below-this">There’s a horizontal rule below this.</h3>

<hr />

<h3 id="here-is-an-unordered-list">Here is an unordered list:</h3>

<ul>
  <li>Item foo</li>
  <li>Item bar</li>
  <li>Item baz</li>
  <li>Item zip</li>
</ul>

<h3 id="and-an-ordered-list">And an ordered list:</h3>

<ol>
  <li>Item one</li>
  <li>Item two</li>
  <li>Item three</li>
  <li>Item four</li>
</ol>

<h3 id="and-a-nested-list">And a nested list:</h3>

<ul>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item
        <ul>
          <li>level 3 item</li>
          <li>level 3 item</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item</li>
      <li>level 2 item</li>
    </ul>
  </li>
  <li>level 1 item
    <ul>
      <li>level 2 item</li>
      <li>level 2 item</li>
    </ul>
  </li>
  <li>level 1 item</li>
</ul>

<h3 id="small-image">Small image</h3>

<p><img src="https://github.githubassets.com/images/icons/emoji/octocat.png" alt="Octocat" /></p>

<h3 id="large-image">Large image</h3>

<p><img src="https://guides.github.com/activities/hello-world/branching.png" alt="Branching" /></p>

<h3 id="definition-lists-can-be-used-with-html-syntax">Definition lists can be used with HTML syntax.</h3>

<dl>
<dt>Name</dt>
<dd>Godzilla</dd>
<dt>Born</dt>
<dd>1952</dd>
<dt>Birthplace</dt>
<dd>Japan</dd>
<dt>Color</dt>
<dd>Green</dd>
</dl>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The final element.
</code></pre></div></div>
:ET